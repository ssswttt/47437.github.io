<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>函数图像绘制工具</title>
    <link rel="stylesheet" href="theme.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        accent: '#8B5CF6',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .shadow-soft {
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            }
            .transition-all-300 {
                transition: all 300ms ease-in-out;
            }
        }
    </style>
</head>
<body class="font-sans text-dark">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- 标题区域 -->
        <header class="mb-8 text-center">
            <h1 class="text-[clamp(1.8rem,4vw,2.5rem)] font-bold text-dark mb-2">函数图像绘制工具</h1>
            <p class="text-gray-600 max-w-2xl mx-auto">输入函数表达式，实时查看函数图像</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- 控制面板 -->
            <div class="lg:col-span-1 bg-white rounded-xl shadow-soft p-6">
                <h2 class="text-xl font-semibold mb-4 flex items-center">
                    <i class="fa fa-sliders text-primary mr-2"></i>函数设置
                </h2>
                
                <!-- 函数类型选择 -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">函数类型</label>
                    <select id="functionType" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary transition-all-300">
                        <option value="linear">一次函数 (y = kx + b)</option>
                        <option value="quadratic">二次函数 (y = ax² + bx + c)</option>
                        <option value="inverse">反比例函数 (y = k/x)</option>
                        <option value="sine">正弦函数 (y = A·sin(Bx + C) + D)</option>
                        <option value="cosine">余弦函数 (y = A·cos(Bx + C) + D)</option>
                        <option value="tangent">正切函数 (y = A·tan(Bx + C) + D)</option>
                        <option value="custom">自定义函数</option>
                    </select>
                </div>
                
                <!-- 参数输入区域 -->
                <div id="parameters" class="space-y-4 mb-6">
                    <!-- 参数将根据选择的函数类型动态生成 -->
                </div>
                
                <!-- 自定义函数输入 -->
                <div id="customFunctionInput" class="hidden mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">函数表达式 (使用x作为变量)</label>
                    <input type="text" id="customFunction" placeholder="例如: x^2 + 3*x - 5 或 sin(x)" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary transition-all-300">
                    <p class="text-xs text-gray-500 mt-1">支持的运算符: +, -, *, /, ^(幂)；支持的函数: sin, cos, tan, log, sqrt</p>
                </div>
                
                <!-- 坐标轴范围设置 -->
                <div class="mb-6 pt-4 border-t border-gray-100">
                    <h3 class="text-sm font-semibold text-gray-700 mb-3">坐标轴范围</h3>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">X轴最小值</label>
                            <input type="number" id="xMin" value="-10" step="0.5" class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-lg">
                        </div>
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">X轴最大值</label>
                            <input type="number" id="xMax" value="10" step="0.5" class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-lg">
                        </div>
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">Y轴最小值</label>
                            <input type="number" id="yMin" value="-10" step="0.5" class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-lg">
                        </div>
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">Y轴最大值</label>
                            <input type="number" id="yMax" value="10" step="0.5" class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-lg">
                        </div>
                    </div>
                </div>
                
                <!-- 按钮区域 -->
                <div class="flex space-x-3">
                    <button id="plotButton" class="flex-1 bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg transition-all-300 flex items-center justify-center">
                        <i class="fa fa-line-chart mr-2"></i>绘制图像
                    </button>
                    <button id="resetButton" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-lg transition-all-300">
                        <i class="fa fa-refresh"></i>
                    </button>
                </div>
            </div>
            
            <!-- 图像显示区域 -->
            <div class="lg:col-span-2 bg-white rounded-xl shadow-soft p-6 flex flex-col">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold flex items-center">
                        <i class="fa fa-area-chart text-accent mr-2"></i>函数图像
                    </h2>
                    <div class="text-sm text-gray-500 bg-gray-100 px-3 py-1 rounded-full">
                        <span id="functionDisplay">y = sin(0.5x)</span>
                    </div>
                </div>
                
                <!-- 画布容器 -->
                <div class="relative flex-1 min-h-[400px]">
                    <canvas id="functionPlot" class="w-full h-full"></canvas>
                    
                    <!-- 加载指示器 -->
                    <div id="loadingIndicator" class="hidden absolute inset-0 flex items-center justify-center bg-white/80 rounded-lg">
                        <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"></div>
                    </div>
                </div>
                
                <!-- 错误消息 -->
                <div id="errorMessage" class="mt-4 hidden bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg text-sm">
                    <i class="fa fa-exclamation-circle mr-2"></i>
                    <span id="errorText"></span>
                </div>
            </div>
        </div>
        
        <!-- 使用说明 -->
        <div class="mt-8 bg-white rounded-xl shadow-soft p-6">
            <h2 class="text-xl font-semibold mb-4 flex items-center">
                <i class="fa fa-info-circle text-primary mr-2"></i>使用说明
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-gray-700">
                <div>
                    <h3 class="font-medium text-dark mb-2">函数类型说明</h3>
                    <ul class="list-disc pl-5 space-y-1 text-sm">
                        <li>一次函数: y = kx + b (k为斜率，b为截距)</li>
                        <li>二次函数: y = ax² + bx + c (a≠0)</li>
                        <li>反比例函数: y = k/x (k≠0)</li>
                        <li>正弦函数: y = A·sin(Bx + C) + D (A:振幅, B:频率, C:相位, D:偏移)</li>
                        <li>余弦函数: y = A·cos(Bx + C) + D</li>
                        <li>正切函数: y = A·tan(Bx + C) + D</li>
                        <li>自定义函数: 支持基本运算和常见数学函数</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-medium text-dark mb-2">操作说明</h3>
                    <ul class="list-disc pl-5 space-y-1 text-sm">
                        <li>修改参数后点击"绘制图像"按钮更新图像</li>
                        <li>点击"重置"按钮恢复默认参数</li>
                        <li>可通过修改坐标轴范围调整视图</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- 页脚 -->
        <footer class="mt-10 text-center text-gray-500 text-sm">
            <p>函数图像绘制工具 © 2023</p>
        </footer>
    </div>

    <script>
        // 全局变量
        let chart;
        let originalRange = {
            x: { min: -10, max: 10 },
            y: { min: -10, max: 10 }
        };

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化参数输入框
            updateParameterInputs();
            
            // 等待DOM完全就绪后初始化图表
            setTimeout(() => {
                initChart();
                // 初始化时绘制默认函数
                plotFunction();
            }, 100);
            
            // 事件监听
            document.getElementById('functionType').addEventListener('change', updateParameterInputs);
            document.getElementById('plotButton').addEventListener('click', plotFunction);
            document.getElementById('resetButton').addEventListener('click', resetSettings);
        });

        // 初始化图表
        function initChart() {
            const ctx = document.getElementById('functionPlot').getContext('2d');
            
            // 销毁已存在的图表（如果有）
            if (chart) {
                chart.destroy();
            }
            
            // 创建图表
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: '函数曲线',
                        data: [],
                        borderColor: '#3B82F6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        tension: 0.1,
                        showLine: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'center',
                            min: originalRange.x.min,
                            max: originalRange.x.max,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawOnChartArea: true
                            },
                            ticks: {
                                stepSize: 1
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'center',
                            min: originalRange.y.min,
                            max: originalRange.y.max,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawOnChartArea: true
                            },
                            ticks: {
                                stepSize: 1
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `(${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                                }
                            }
                        },
                        legend: {
                            display: false
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    animation: {
                        duration: 300
                    },
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y'
                    }
                }
            });
        }

        // 更新参数输入框
        function updateParameterInputs() {
            const functionType = document.getElementById('functionType').value;
            const parametersDiv = document.getElementById('parameters');
            const customInputDiv = document.getElementById('customFunctionInput');
            
            // 清空现有参数
            parametersDiv.innerHTML = '';
            
            // 根据函数类型显示不同的参数输入框
            switch (functionType) {
                case 'linear':
                    customInputDiv.classList.add('hidden');
                    addParameterInput(parametersDiv, 'k', '斜率 k', 1);
                    addParameterInput(parametersDiv, 'b', '截距 b', 0);
                    break;
                case 'quadratic':
                    customInputDiv.classList.add('hidden');
                    addParameterInput(parametersDiv, 'a', '系数 a', 1);
                    addParameterInput(parametersDiv, 'b', '系数 b', 0);
                    addParameterInput(parametersDiv, 'c', '常数项 c', 0);
                    break;
                case 'inverse':
                    customInputDiv.classList.add('hidden');
                    addParameterInput(parametersDiv, 'k', '系数 k', 1);
                    break;
                case 'sine':
                    customInputDiv.classList.add('hidden');
                    addParameterInput(parametersDiv, 'A', '振幅 A', 1);
                    addParameterInput(parametersDiv, 'B', '频率 B', 0.5);
                    addParameterInput(parametersDiv, 'C', '相位 C', 0);
                    addParameterInput(parametersDiv, 'D', '偏移 D', 0);
                    break;
                case 'cosine':
                    customInputDiv.classList.add('hidden');
                    addParameterInput(parametersDiv, 'A', '振幅 A', 1);
                    addParameterInput(parametersDiv, 'B', '频率 B', 0.5);
                    addParameterInput(parametersDiv, 'C', '相位 C', 0);
                    addParameterInput(parametersDiv, 'D', '偏移 D', 0);
                    break;
                case 'tangent':
                    customInputDiv.classList.add('hidden');
                    addParameterInput(parametersDiv, 'A', '振幅 A', 1);
                    addParameterInput(parametersDiv, 'B', '频率 B', 0.5);
                    addParameterInput(parametersDiv, 'C', '相位 C', 0);
                    addParameterInput(parametersDiv, 'D', '偏移 D', 0);
                    break;
                case 'custom':
                    customInputDiv.classList.remove('hidden');
                    document.getElementById('customFunction').value = 'x^2';
                    break;
            }
        }

        // 添加参数输入框
        function addParameterInput(container, id, label, defaultValue) {
            const div = document.createElement('div');
            div.className = 'parameter-input';
            div.innerHTML = `
                <label for="${id}" class="block text-sm font-medium text-gray-700 mb-1">${label}</label>
                <input type="number" id="${id}" value="${defaultValue}" step="0.1"
                       class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary transition-all-300">
            `;
            container.appendChild(div);
            
            // 添加输入事件监听
            const input = div.querySelector(`#${id}`);
            input.addEventListener('input', function() {
                if (isNaN(parseFloat(this.value)) && this.value !== "") {
                    this.classList.add('border-red-500');
                } else {
                    this.classList.remove('border-red-500');
                }
            });
        }

        // 格式化系数显示
        function formatCoefficient(value, isFirstTerm = false) {
            // 处理接近整数的浮点数
            const rounded = Math.round(value * 1000) / 1000;
            
            // 系数为1或-1的情况
            if (rounded === 1) {
                return isFirstTerm ? '' : '+';
            }
            if (rounded === -1) {
                return '-';
            }
            
            // 系数为0的情况
            if (rounded === 0) {
                return '';
            }
            
            // 正数且不是第一项，需要添加"+"
            if (rounded > 0 && !isFirstTerm) {
                return `+${rounded}`;
            }
            
            return rounded.toString();
        }

        // 格式化三角函数的B值显示（新增函数）
        function formatTrigonometricB(value) {
            // 处理接近整数的浮点数
            const rounded = Math.round(value * 1000) / 1000;
            
            // 系数为1或-1的情况
            if (rounded === 1) {
                return '';  // 不显示系数
            }
            if (rounded === -1) {
                return '-';  // 只显示负号
            }
            
            // 系数为0的情况
            if (rounded === 0) {
                return '';
            }
            
            // 直接返回数值，不添加"+"号
            return rounded.toString();
        }

        // 格式化常数项显示
        function formatConstant(value) {
            const rounded = Math.round(value * 1000) / 1000;
            
            if (rounded === 0) {
                return '';
            }
            
            return rounded > 0 ? `+${rounded}` : rounded.toString();
        }

        // 绘制函数图像
        function plotFunction() {
            showLoading();
            hideError();
            
            try {
                const functionType = document.getElementById('functionType').value;
                const xMin = parseFloat(document.getElementById('xMin').value);
                const xMax = parseFloat(document.getElementById('xMax').value);
                const yMin = parseFloat(document.getElementById('yMin').value);
                const yMax = parseFloat(document.getElementById('yMax').value);
                
                // 验证坐标轴范围
                if (xMin >= xMax) throw new Error("X轴最小值必须小于最大值");
                if (yMin >= yMax) throw new Error("Y轴最小值必须小于最大值");
                
                // 根据函数类型计算数据点
                let func, funcDisplay;
                
                switch (functionType) {
                    case 'linear':
                        const k = parseFloat(document.getElementById('k').value);
                        const b = parseFloat(document.getElementById('b').value);
                        if (isNaN(k) || isNaN(b)) throw new Error("请输入有效的k和b值");
                        func = (x) => k * x + b;
                        
                        // 优化一次函数显示
                        const kFormatted = formatCoefficient(k, true);
                        const bFormatted = formatConstant(b);
                        funcDisplay = `y = ${kFormatted}x${bFormatted}`;
                        break;
                        
                    case 'quadratic':
                        const a = parseFloat(document.getElementById('a').value);
                        const b2 = parseFloat(document.getElementById('b').value);
                        const c = parseFloat(document.getElementById('c').value);
                        if (isNaN(a) || isNaN(b2) || isNaN(c)) throw new Error("请输入有效的a、b和c值");
                        if (a === 0) throw new Error("二次函数的a值不能为0");
                        func = (x) => a * x * x + b2 * x + c;
                        
                        // V7版本的二次函数显示逻辑（新增判断）
                        const aFormatted = formatCoefficient(a, true);
                        let b2Formatted = "";
                        let xTerm = "";
            
                        // 仅当b不为0时才显示x项（使用0.001作为浮点数精度阈值）
                        if (Math.abs(b2) > 0.001) {
                            b2Formatted = formatCoefficient(b2);
                            xTerm = `${b2Formatted}x`;
                        }
            
                        const cFormatted = formatConstant(c);
                        funcDisplay = `y = ${aFormatted}x²${xTerm}${cFormatted}`;
                        break;
                        
                    case 'inverse':
                        const kInv = parseFloat(document.getElementById('k').value);
                        if (isNaN(kInv)) throw new Error("请输入有效的k值");
                        if (kInv === 0) throw new Error("反比例函数的k值不能为0");
                        func = (x) => {
                            if (Math.abs(x) < 0.01) return null;
                            return kInv / x;
                        };
                        
                        // 优化反比例函数显示
                        const kInvFormatted = kInv === 1 ? '' : kInv === -1 ? '-' : kInv.toString();
                        funcDisplay = `y = ${kInvFormatted}/x`;
                        break;
                        
                    case 'sine':
                        const A = parseFloat(document.getElementById('A').value);
                        const B = parseFloat(document.getElementById('B').value);
                        const C = parseFloat(document.getElementById('C').value);
                        const D = parseFloat(document.getElementById('D').value);
                        if (isNaN(A) || isNaN(B) || isNaN(C) || isNaN(D)) throw new Error("请输入有效的A、B、C和D值");
                        func = (x) => A * Math.sin(B * x + C) + D;
                        
                        // 优化正弦函数显示
                        const AFormatted = formatCoefficient(A, true);
                        const BFormatted = formatTrigonometricB(B);  // 使用新函数
                        const CFormatted = formatConstant(C);
                        const DFormatted = formatConstant(D);
                        funcDisplay = `y = ${AFormatted}sin(${BFormatted}x${CFormatted})${DFormatted}`;
                        break;
                        
                    // 余弦函数部分
                    case 'cosine':
                        const Ac = parseFloat(document.getElementById('A').value);
                        const Bc = parseFloat(document.getElementById('B').value);
                        const Cc = parseFloat(document.getElementById('C').value);
                        const Dc = parseFloat(document.getElementById('D').value);
                        if (isNaN(Ac) || isNaN(Bc) || isNaN(Cc) || isNaN(Dc)) throw new Error("请输入有效的A、B、C和D值");
                        func = (x) => Ac * Math.cos(Bc * x + Cc) + Dc;
                        
                        // 优化余弦函数显示
                        const AcFormatted = formatCoefficient(Ac, true);
                        const BcFormatted = formatTrigonometricB(Bc);  // 使用新函数
                        const CcFormatted = formatConstant(Cc);
                        const DcFormatted = formatConstant(Dc);
                        funcDisplay = `y = ${AcFormatted}cos(${BcFormatted}x${CcFormatted})${DcFormatted}`;
                        break;
                        
                    // 正切函数部分
                    case 'tangent':
                        const At = parseFloat(document.getElementById('A').value);
                        const Bt = parseFloat(document.getElementById('B').value);
                        const Ct = parseFloat(document.getElementById('C').value);
                        const Dt = parseFloat(document.getElementById('D').value);
                        if (isNaN(At) || isNaN(Bt) || isNaN(Ct) || isNaN(Dt)) throw new Error("请输入有效的A、B、C和D值");
                        
                        // 正切函数的数学定义：f(x) = A·tan(B·x + C) + D，定义域为x ≠ (π/2 + kπ - C)/(B)，k为整数
                        func = (x) => {
                            const angle = Bt * x + Ct;
                            
                            // 检查是否接近渐近线（使用更精确的检查方法）
                            const mod = angle % Math.PI;
                            // 为了避免浮点精度问题，使用0.001作为误差范围
                            if (Math.abs(mod - Math.PI/2) < 0.001 || Math.abs(mod + Math.PI/2) < 0.001) {
                                return null; // 在渐近线处返回null，不绘制该点
                            }
                            
                            const tanValue = Math.tan(angle);
                            // 检查正切值是否为有效数值（避免极端值）
                            if (!isFinite(tanValue)) {
                                return null;
                            }
                            
                            return At * tanValue + Dt;
                        };
                        
                        // 优化正切函数显示
                        const AtFormatted = formatCoefficient(At, true);
                        const BtFormatted = formatTrigonometricB(Bt);  // 使用新函数
                        const CtFormatted = formatConstant(Ct);
                        const DtFormatted = formatConstant(Dt);
                        funcDisplay = `y = ${AtFormatted}tan(${BtFormatted}x${CtFormatted})${DtFormatted}`;
                        break;
                        
                    case 'custom':
                        const customExpr = document.getElementById('customFunction').value;
                        if (!customExpr.trim()) throw new Error("请输入自定义函数表达式");
                        func = createCustomFunction(customExpr);
                        funcDisplay = `y = ${customExpr}`;
                        break;
                }
                
                // 更新显示的函数表达式
                document.getElementById('functionDisplay').textContent = funcDisplay;
                
                // 生成数据点
                const numPoints = 2000;
                const step = (xMax - xMin) / numPoints;
                
                // 对于反比例函数，创建两个数据集，分别存储左右两侧的点
                if (functionType === 'inverse') {
                    // 左侧数据集（x < 0）
                    const leftPoints = [];
                    // 右侧数据集（x > 0）
                    const rightPoints = [];
                    
                    for (let i = 0; i <= numPoints; i++) {
                        const x = xMin + i * step;
                        const y = func(x);
                        
                        // 检查是否为有效数值
                        if (y !== null && !isNaN(y) && isFinite(y)) {
                            if (x < 0) {
                                leftPoints.push({ x, y });
                            } else if (x > 0) {
                                rightPoints.push({ x, y });
                            }
                        }
                    }
                    
                    // 检查是否生成了数据点
                    if (leftPoints.length === 0 && rightPoints.length === 0) {
                        throw new Error("无法生成有效的函数数据点，请检查函数参数或调整坐标轴范围");
                    }
                    
                    // 清空现有数据集
                    chart.data.datasets = [];
                    
                    // 添加左侧数据集
                    if (leftPoints.length > 0) {
                        chart.data.datasets.push({
                            label: '左侧曲线',
                            data: leftPoints,
                            borderColor: '#3B82F6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.1,
                            showLine: true
                        });
                    }
                    
                    // 添加右侧数据集
                    if (rightPoints.length > 0) {
                        chart.data.datasets.push({
                            label: '右侧曲线',
                            data: rightPoints,
                            borderColor: '#3B82F6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.1,
                            showLine: true
                        });
                    }
                } else {
                    // 非反比例函数，使用原来的单数据集方式
                    const points = [];
                    
                    for (let i = 0; i <= numPoints; i++) {
                        const x = xMin + i * step;
                        const y = func(x);
                        
                        // 检查是否为有效数值
                        if (y !== null && !isNaN(y) && isFinite(y)) {
                            points.push({ x, y });
                        }
                    }
                    
                    // 检查是否生成了数据点
                    if (points.length === 0) {
                        throw new Error("无法生成有效的函数数据点，请检查函数参数或调整坐标轴范围");
                    }
                    
                    // 更新图表数据
                    chart.data.datasets = [{ // 重设数据集
                        label: '函数曲线',
                        data: points,
                        borderColor: '#3B82F6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        tension: 0.1,
                        showLine: true
                    }];
                }
                
                // 更新图表配置
                chart.options.scales.x.min = xMin;
                chart.options.scales.x.max = xMax;
                chart.options.scales.y.min = yMin;
                chart.options.scales.y.max = yMax;
                chart.update();
                
                // 保存当前范围作为原始范围
                originalRange = {
                    x: { min: xMin, max: xMax },
                    y: { min: yMin, max: yMax }
                };
                
            } catch (error) {
                showError(error.message || '绘制函数时发生错误，请检查输入参数');
            } finally {
                hideLoading();
            }
        }

        // 创建自定义函数
        function createCustomFunction(expr) {
            let processedExpr = expr
                .replace(/(\d)([a-zA-Z])/g, '$1*$2') // 处理隐含的乘法，如 2x → 2*x
                .replace(/\^/g, '**') // 替换幂运算 ^ 为 **
                .replace(/log/g, 'Math.log')
                .replace(/sin/g, 'Math.sin')
                .replace(/cos/g, 'Math.cos')
                .replace(/tan/g, 'Math.tan')
                .replace(/sqrt/g, 'Math.sqrt')
                .replace(/pi/g, 'Math.PI')
                .replace(/e/g, 'Math.E');
            
            try {
                return new Function('x', `return ${processedExpr};`);
            } catch (error) {
                throw new Error(`函数表达式无效: ${expr}`);
            }
        }

        // 重置设置
        function resetSettings() {
            document.getElementById('functionType').value = 'linear';
            document.getElementById('xMin').value = -10;
            document.getElementById('xMax').value = 10;
            document.getElementById('yMin').value = -10;
            document.getElementById('yMax').value = 10;
            
            updateParameterInputs();
            initChart(); // 重置图表而不是视图
            plotFunction();
        }

        // 显示加载指示器
        function showLoading() {
            document.getElementById('loadingIndicator').classList.remove('hidden');
        }

        // 隐藏加载指示器
        function hideLoading() {
            document.getElementById('loadingIndicator').classList.add('hidden');
        }

        // 显示错误消息
        function showError(message) {
            const errorElement = document.getElementById('errorText');
            errorElement.textContent = message;
            document.getElementById('errorMessage').classList.remove('hidden');
        }

        // 隐藏错误消息
        function hideError() {
            document.getElementById('errorMessage').classList.add('hidden');
        }
    </script>
</body>
</html>